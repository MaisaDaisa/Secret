3) რომელი მსჯელობაა სწორი სტრიქონების შესახებ:
---a) კლასის ობეიქტის გამოძახებისას მეხსიერებეა გამოიყოფა (განაცხადის) გაკეთების მომენტში დო ობიექტი იგივდება იმ სახელთან, რომელიც (განაცხადშია) მითითებული
4)რომელი ოპერატორის გამოყენება არ შეიძლება სტრიქონის კლასის ობიექტზე:
---d) *= ;
5) სტრიქონის შექმნის მომენტში ცარიელ სტრიქონს თავიდნავე გამოეყოფა:
---c) 15 ბაიტი
6) s.append(str,0,6) ფუნქცია:
---c) აბრუნებს (სახელ...) სტრიქონს str-ს, რომელსაც ბოლოში დაემატება str-ის პრიველი 6 სიმბოლო
7) ფუნქცია str.empty():
---c) ამოწმებს ცარიელია თუ არა სტრიქონი;
8) s.erase(s.begin(), s.begin()+4) ფუნქცია:
---c) s სტრიქონიდან წაშლის პირველიდან   მეხუთემდე სიმბოლოებს;
9) str.find("a", pos) ფუნქცია:
---b) str სტრიქონში იპოვის a სიმბოლოს პირველ გამოცენას pos პოზიციის შემდეგ
10) reverse(str.begin()+2, str.end()-4) ფუნქცია: 
---b) შეაბრუნებს str სტრიქონს დაწყებული მე-3 პოზიციიდან ბოლოდან მე-4 პზიციამდე
11) str1.insert(8, str2) ფუნქცია:
--- b) str2 სტრიქონს ჩაამატებს str1 სტრიქონში 8 პოზიციიდან.
12) str1.replace(0, 4, str2) ფუქნცია:
--- c) str1 სტრიქონის პირველ 4 პოზიციას ჩაანაცვლევბს str2 სტრიქონი;
13) str1.compare(str2); ფუნქცია მთელ რიცხვს. რომელი მსჯელობაა სწორი:
--- a) თუ რიცხვი დადებითია str1 მეტია str2-ზე და რიცხვის მნიშვნელობა გვიჩვენებს პირველი განსხვავებული სიმბოლოს კოდებს შორის სხვაობას; 
14) ორი სტრიქონის შედარების შეგეგია:
--- b) მთელი ტიპის სიდიდე 
15)  sort(V.rbegin(), V.rend()) ფუნქცია ვექტორი დაალაგებს:
---  b) კლებადობის მიხედვით 
16) count_if( Vec.begin(), Vec.end()) მიმართვა ფუნქციის პრედეკატზე:
--- b) დაითვლის იმ ელემენტების რაოდენობას, რომელზეც პრედეკატი დააბრუნებს მცდარ მნიშვნელობას
17) Vector კლასზე განსაზღვრული max_element ფუნქციის პროტოტიპია 
Forward It   min_element(....
--- d) ფუნქციის არგუმენტებია იტერატორები, დასაბრუნებელი ტიპიც იტერატორი; 
18)  Vector კლასზე განსაზღვრული max_element ფუნქციის პროტოტიპია 
Forward It   max_element(ForwardIt first, ForwardIt last); რომელი მსჯელობაა სწორი
--- d) ფუნქციის არგუმენტებია იტერატორები, დასაბრუნებელი ტიპიც იტერატორი; 
19) count_if (Forward(..) first, Forward last, UnaryPredicate pred)
--- c) ფუნქციის არგუმენტებია იტერატორები და ფუნქიცა (დასაბრუნებელი) მთელი ტიპი
20)  begin() და end() იტერატორები შესაბამისად მიმათავენ (კონ...)
--- b) პირველი და ბოლოს მომდევნო ელემენტებს
21) rend() და rbegin() იტერატორები შესაბამისად მიმათავენ (კონ...)
--- c) პირველის წინა და ბოლო ელემენტებს;
22) ალგორითმების ერთი ბიჯის დარგლებში სხვადასხვა ბრძანების შესრულება (დაუშვებელია) - ალგორითმის ეს თვისება:
--- a) დისკრეყულობა
23) ევკლიდეს ალგორითმი შეეხება
--- b) უდიდესი საერთო გამყოფის პოვნას
24) სიმრავლეები რომელებიც იცვლებიან ალგორითმის მუშაობს პროცესში არის:
--- a) დინამიური სიმრავლეები
25) დინამიური სიმრავლეების ელემეტს წარმოადგენს ჩანაწერი, რომელიც შეადგენს სხვადასხვა მიმდევრობის ველს, რომელიც განკუთვნილია ელემენტის ცალსახად განსაზღვრისთვის ეწოდება:
--- b) გასაღები (key)


----------------
26) მოქმედებებს სიმრავლეებზე, რომლებიც _____არ____ ცვლიან სიმრავლეებს ეწოდებათ:
---b)	(queris) მიმართვები;  
27) მოქმედებებს სიმრავლეებზე, რომლებიც ____________ ცვლიან სიმრავლეებს ეწოდებათ:
---a) (modifying operations) ოპერაციები;
-----------

-----------------
28) სიმრავლეებზე ჩატარებული ოპერაციების ღირებულება დამოკიდებულია:
---b) იმ სიმრავლეების ზომებზე, რომლეთა (მიმართავ) ისნი გამოიყენებიან
29) წრფივი სიები მიეკუთვნება:
---b) დინამიურ სიმრავლეებს
---------------

30) წრფივ სიებზე არ არის შესაძლებელი შემდეგი მოქმედების შესრულება: -----ცუდად ჩანს
---b) სიის შუაში მდგომი ელემენტის (...)
31) წრფივ სიებზე არ არის შესაძლებელი შემდეგი მოქმედების შესრულება: ----- ძაან ცუდად ჩანს
---d) (ერთი ელემენტის რომელიმე მიმდევრობისთვის (გასაღების) მის.... წიხ....)
32) სტეკი (არის) წრფივი სია, რომელიც
---a) რომელიც ჩასმის, წაშლის და .... მხოლოდ სიის ერთ ბოლოზე
33) რიგი ანუ ცალმხრივი რიგი - ესაა წრფივი სია:
---b) რომელშიც ჩასმის ყველა ოპერაცია ხორციელდება ერთ ბოლოზე , ხოლო წაშლის და როგორც წესი,
მნიშვნელობებზე მიმართვის ოპერაცია – მეორე ბოლოზე;
34)დეკი ანუ ორმხრივი რიგი – ესაა წრფივი სია:
---c) რომელშიც ჩასმის, წაშლის და მნიშვნელობებზე მიმართვის ოპერაციები ხდება სიის ორივე ბოლოზე;
35) სტეკის მუშაობის პრინციპია: (ან სტეკის მოქმედების)
---a) “ბოლოს მოვიდა – პირველი წავიდა” LIFO
36) რიგის მოქმედების პრინციპია: (ან რიგის მუშაობის)
---b) “პირველად მოვიდა – პირველი წავიდა” FIFO
37) სტეკთნ დაკავშირებული სამი ოპერატორია - ელემენტის (....), წაშ₾ა და ელემენტზე მიმართვა:
--- b) სამივე ოპერაიცა სრულდება O(1) დროში
38) სტეკი გამოიყენება: 
--- a) ფუნქციის გამოძახების, ლოკალური ცვლადების მართვისთვის და ოპერაციების რიგის შესანარჩუნებლად.
39) რიგი გამოიყენება:
--- b) მონაცემთა ნაკადების  ბუფერიზაციის პროცესის უზრუნველსაყოფად, ინფორმაციული პაკეტების ნაკადის მოსაწესრიგებლად კომპიუტერულ ქსელებში; 
40) დეკი გამოიყენება:
--- c) იაგრამის გადაკვეთის ალგორითმებში, ამოცანების სიის სამართავად, მეხსიერების 
41) ელემენტებზე წვდომა შეიძლება განხორციელდეს იტერატორების საშუალებით:
--- c) დეკში;
42) წრფივი სიის ერთერთ (სახეში) წაშლის ოპერაციის შესრულებისას პირველ ყოვლისა წაიშლება
სიის ყველაზე “უმცროსი” ობიექტი, ანუ ობიექტი, რომელიც ყველაზე ბოლოს
იქნა ჩასმული:
---b) სტეკში
43) წრფივი სიის ერთერთ სახეში ყველაზე ადრე წაიშლება "უფროსი" ობიექტი, ანუ ის, რომელიც ყველაზე ადრე ჩაისვა:
---a) რიგში
44) მიმართვა იმ ელემენტზე, რომელიც მოთავსებულია სტეკის ფსკერზე, -------- (ეს არ ვიცი რა არის არ ჩანს) 
რკვეულწილად გართულებულია, რადგან მას ვერ მივმართავთ მანამ, 
---c) სტეკიდან ყველა სხვა ელემენტის  წაშლის შემდეგ
45) "დასაწყისი” (front) და “ბოლო” (rear) აქვს წრფივი სიის ერთ ერთ სახეს:
---b) რიგს;
46) სტეკთან დაკავშირებული ოპერაციები სრულდება:
---a) სამივე O(1) დროში.
47) ფუნქციის გამოძახების, ლოკალური ცვლადების მართვისთვის და ოპერაციების რიგის შესანარჩუნებლად გამოიყენება:
---b) სტეკი
48) არგუმენტის გადაცემის რომელ ხერხს ვერ გამოვიყენებთ ფუნქციაში სტეკის (რიგის, დეკის) გადაცემისას: 
--- c) pass-by-value; 
49) არითმეტიკული გამოსახულების ინფიქსური ფრმიდან პოსფიქსურ ფორმაზე გარდაქმნის დროს გამოსახულებაში აღარ ჩაიწერება:
---b) გამხსნელი და დამხურავი ფრჩხილები
50) რომელი მსჯელობაა მართებული არითმეტიკული გამოსახულების ინფიქსური ფორმიდან პოსტფიქსურ ფორმაზე გარდაქმნის პროცესზე მსჯელობისას:
---c) მარჯვენა ფრჩხილი სტეკიდან გამომავალ სტრიქონში გამოაძევებს ყველა ოპერაციის უახლოეს მარცხენა ფრჩხილებამდე


------------------------
51) რომელი მსჯელობაა მართებული არითმეტიკული გამოსახულების ინფიქსური ფორმიდან პოსტფიქსურ ფორმაზე გარდაქმნის პროცესზე მსჯელობისას :
---b) თუ სტეკი ცარიელია, ან სტეკის ზედაპირზე მოთავსებულ ოპერაციას ნაკლები პრიორიტეტი აქვს, ვიდრე განსახილველს, ოპერაცია თავსდება სტეკში; 

52)


53) (............) ფორმიდან პოსტფიქსურ ფორმაზე გარდაქმნის პროცესზე (მსელობისას)
a) მარჯვენა ფრჩხილი ყოველთვის თავსდება სვეტში
----- b) მარცხენა ფრჩხილი ყოველთვის თავსდება სვეტში
d) ორივე ფრჩხილი თავსდება სვეტში
d) ფრჩხილების სტეკში ჩატვირთვა დამოკიდებულია ოპერაციების პრიორიტეტებზე
-------------------------


54) რომელი მსჯელობაა სწორი პოსტფიქსური გამოსახულებების შესრულების შესახებ:
---- b) იდენტიფიკატორის რიცხვითი მნიშვნელობა (ან რიცხვი) პირდაპირ (გადაიწერება) სტეკში
55) პოსტფიქსური გამოსახულების შესრულების დროს თუკი გამოსახულებაში გვხვდება ოპერაციის ნიშანი (ვთქვათ, * ) და სტეკის ზედაპირზეა x, ხოლო მის ქვემოთ y:
---b) სრულდება y * x ოპერაცია. სტეკიდან გამოძევდება x-იც და y-იც და მათ ნაცვლად თავსდება შესრულებული ოპერაციის შედეგი; 
56) წრფივი სიის ერთ-ერთი სახე გამოიყენება დასაბეჭდათ გამზადებული მონაცემთა ნაკადების ბუფერიქაციის პროცესის უზრუნვეკყოდად, ეს არის:
---a) რიგი
57) წრფივი სიის ერთ ერთი სახე გამოიყენება კომპიუტერულ ქსელში ინფორმაციული პაკეტების გადაცემის პროცესის მოსაწესრიგებლად, ეს არის:
---a) რიგი
58) წრფივი სიაში ელემენტების წვდომა ხორციელდება მხოლოდ ორ ელემენტზე, ჩატვირთვა ხდება ბოლოდან, წაშლა თავიდან, ეს სიაა:
---c) რიგი
59) სია რომელიც საშუალებას გვაძლევს ახალი ელემენტი დაემატოს როგორც დასაწყისში ასევე ბოლოში არის: 
--- c) დეკი

------------
60) მართებულია თუ არა აზრი,რომ ___დეკის___ ელემენტებზე წვდომა შეიძ₾ება განხორციელდეს იტერატორის საშუალებით:
--- a) კი
61) მართებულია თუ არა აზრი, რომ ___სტეკის___ ელემენტებზე წვდომა შეიძლება განხორციელდეს იტერატორის შაშუალებით
---b) არა
--------------